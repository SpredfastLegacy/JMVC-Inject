// Generated by CoffeeScript 1.3.3
(function() {
  var factoryName, getOptions, processDef, resolveFactory, substitute, support,
    __slice = [].slice;

  support = null;

  factoryName = /^([^(]+)(\((.*?)?\))?$/;

  getOptions = function(Class, support, args) {
    var d, def, el, _i, _len, _ref;
    el = args[0];
    def = support.definition(Class.fullName);
    _ref = (def != null ? def.controllerDefs : void 0) || [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      d = _ref[_i];
      if (!d.controller || el.is(d.controller)) {
        def = d;
      }
    }
    return def != null ? def.options : void 0;
  };

  processDef = function(target, defs) {
    var byKey, d, def, grouped, key, merged, _i, _j, _len, _len1;
    if (!((target != null ? target.element : void 0) && (target != null ? target.Class : void 0))) {
      return;
    }
    grouped = [];
    byKey = {};
    for (_i = 0, _len = defs.length; _i < _len; _i++) {
      d = defs[_i];
      key = d.controller || '';
      merged = byKey[key];
      if (!merged) {
        merged = byKey[key] = {};
        grouped.push(merged);
      }
      $.extend(true, merged, d);
    }
    for (_j = 0, _len1 = grouped.length; _j < _len1; _j++) {
      d = grouped[_j];
      if (!d.controller || target.element.is(d.controller)) {
        def = d;
      }
    }
    def = $.extend(true, {}, def);
    if (def) {
      def.controllerDefs = grouped;
    }
    return def;
  };

  resolveFactory = function(target, name, targetDef) {
    var args, fn, get, parts, path, realName, _ref, _ref1;
    if (!((target != null ? target.element : void 0) && (target != null ? target.Class : void 0))) {
      return;
    }
    get = function(path) {
      return $.String.getObject(path, [target.options]);
    };
    parts = factoryName.exec(substitute(name, target.options) || name);
    realName = (targetDef != null ? (_ref = targetDef.inject) != null ? _ref[parts[1]] : void 0 : void 0) || parts[1];
    args = (function() {
      var _i, _len, _ref1, _ref2, _ref3, _results;
      _ref3 = (_ref1 = (_ref2 = parts[3]) != null ? _ref2.split(',') : void 0) != null ? _ref1 : [];
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        path = _ref3[_i];
        if (path) {
          _results.push(get(path));
        }
      }
      return _results;
    })();
    fn = (_ref1 = support.definition(realName)) != null ? _ref1.factory : void 0;
    return function() {
      if (fn) {
        return fn.apply(this, args);
      }
    };
  };

  substitute = function(string, options) {
    return string.replace(/\{(.+?)\}/g, function(param, name) {
      return $.String.getObject(name, [options]);
    });
  };

  (steal.plugins ? steal('inject-core.js', 'attrs.js').plugins('jquery/lang') : steal('./inject-core.js', './attrs.js', 'jquery/lang/string')).then(function() {
    var $, exports;
    $ = this.$ || this.can;
    exports = Inject;
    /*
    		Important note: jQuery.is is required to use a controller selector.
    */

    Inject.plugin({
      processDefinition: processDef,
      resolveFactory: resolveFactory,
      init: function(s) {
        return support = s;
      }
    });
    exports.setupControllerActions = function() {
      throw new Error('setupControllerActions has changed to the static setupController function');
    };
    return exports.setupController = function() {
      var args, setup;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      Inject.setup.arg(1, getOptions).apply(this, arguments);
      setup = this.prototype.setup;
      this.prototype.setup = function() {
        var action, funcName, _ref;
        _ref = this.Class.actions;
        for (funcName in _ref) {
          action = _ref[funcName];
          this[funcName] = Inject.useCurrent(this[funcName]);
        }
        return setup.apply(this, arguments);
      };
      return args;
    };
  });

}).call(this);
