// Generated by CoffeeScript 1.3.3

/*
	Requirements:
		jQuery or DoneJS/CanJS ($.when and $.extend)
*/


(function() {
  var CONTEXT, D, PLUGINS, andReturn, bind, error, exports, getClass, getName, groupBy, inject, injectUnbound, last, mapper, noContext, pluginSupport, useInjector, whenInjected, window,
    __slice = [].slice;

  window = this;

  exports = window;

  error = window.console && console.error ? function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return console.error.apply(console, args);
  } : function() {};

  bind = function(obj, name) {
    var fn;
    fn = obj[name];
    if (!fn) {
      throw new Error("" + name + " is not defined.");
    }
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return fn.apply(obj, args);
    };
  };

  D = (function() {
    var _ref, _ref1;
    if (window.can) {
      return {
        when: bind(can, 'when'),
        extend: bind(can, 'extend')
      };
    } else {
      if (!(window.jQuery || ((_ref = window.$) != null ? _ref.when : void 0) && ((_ref1 = window.$) != null ? _ref1.extend : void 0))) {
        throw new Error("Either JavaScriptMVC, DoneJS, CanJS or jQuery/Zepto is required.");
      }
      return {
        when: bind(window.jQuery || window.$, 'when'),
        extend: bind(window.jQuery || window.$, 'extend')
      };
    }
  })();

  CONTEXT = [];

  PLUGINS = [];

  inject = function() {
    var configs, d, def, definition, defs, eager, factories, factory, injector, name, resolver, results, _i, _len;
    defs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    factories = {};
    results = {};
    defs = groupBy(defs, 'name');
    eager = [];
    resolver = function(obj) {
      var controller, def, mapping, resolve;
      def = definition(obj);
      controller = def.controllerInstance;
      mapping = mapper(def);
      return resolve = function(name) {
        var factory, plugin, realName, _i, _len;
        realName = mapping(name);
        factory = factories[realName];
        for (_i = 0, _len = PLUGINS.length; _i < _len; _i++) {
          plugin = PLUGINS[_i];
          if (plugin.resolveFactory) {
            factory = plugin.resolveFactory(obj, realName, def) || factory;
          }
        }
        if (!factory) {
          throw new Error("Cannot resolve '" + realName + "' AKA '" + name + "'");
        }
        return factory.call(this);
      };
    };
    definition = function(target) {
      var context, d, def, definitions, name, plugin, _i, _j, _len, _len1;
      context = last(CONTEXT);
      name = context.name || getName(target);
      def = {};
      definitions = (defs[name] || []).slice(0);
      for (_i = 0, _len = PLUGINS.length; _i < _len; _i++) {
        plugin = PLUGINS[_i];
        if (plugin.processDefinition) {
          definitions.push(plugin.processDefinition(target, definitions) || {});
        }
      }
      for (_j = 0, _len1 = definitions.length; _j < _len1; _j++) {
        d = definitions[_j];
        D.extend(true, def, d);
      }
      return def;
    };
    injector = whenInjected(resolver, definition);
    for (name in defs) {
      configs = defs[name];
      def = {};
      for (_i = 0, _len = configs.length; _i < _len; _i++) {
        d = configs[_i];
        D.extend(true, def, d);
      }
      name = def.name;
      factory = def.factory;
      if (def.eager) {
        eager.push(factory);
      }
      factories[name] = factory;
    }
    useInjector({
      injector: injector,
      definition: definition
    }, function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = eager.length; _j < _len1; _j++) {
        factory = eager[_j];
        _results.push(factory());
      }
      return _results;
    }).call(this);
    return injector;
  };

  injectUnbound = function(name) {
    var require;
    return require = function() {
      var args, injectCurrent;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      injectCurrent = function() {
        var context, injected;
        context = last(CONTEXT);
        if (!context) {
          noContext();
        }
        injected = context.injector.named(name).apply(this, args);
        return injected.apply(this, arguments);
      };
      injectCurrent.andReturn = andReturn;
      return injectCurrent;
    };
  };

  inject.require = injectUnbound();

  inject.require.named = injectUnbound;

  useInjector = function(injector, fn) {
    return function() {
      try {
        CONTEXT.push(injector);
        return fn.apply(this, arguments);
      } finally {
        CONTEXT.pop();
      }
    };
  };

  inject.useCurrent = function(fn, ignoreNoContext) {
    var context;
    context = last(CONTEXT);
    if (!(context || ignoreNoContext)) {
      noContext();
    }
    if (context) {
      return useInjector(context, fn);
    } else {
      return fn;
    }
  };

  noContext = function() {
    throw new Error("There is no current injector.\nYou need to call this inside an injected function or an inject.useCurrent function.");
  };

  whenInjected = function(resolver, definition) {
    var destroyed, injector, injectorFor;
    destroyed = false;
    injectorFor = function(name) {
      var requires;
      return requires = function() {
        var dependencies, fn, injectContext, injected, _i;
        dependencies = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fn = arguments[_i++];
        injectContext = {
          injector: injector,
          name: name,
          definition: definition
        };
        fn = useInjector(injectContext, fn);
        injected = useInjector(injectContext, function() {
          var args, d, deferreds, resolve, target;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (destroyed) {
            return;
          }
          target = this;
          resolve = resolver(target);
          try {
            deferreds = (function() {
              var _j, _len, _results;
              _results = [];
              for (_j = 0, _len = dependencies.length; _j < _len; _j++) {
                d = dependencies[_j];
                _results.push(resolve(d));
              }
              return _results;
            })();
          } catch (e) {
            error('Error resolving for target:', target);
            throw e;
          }
          return D.when.apply(D, deferreds.concat(args)).pipe(function() {
            if (!destroyed) {
              return fn.apply(target, arguments);
            }
          });
        });
        injected.andReturn = andReturn;
        return injected;
      };
    };
    injector = injectorFor();
    injector.named = injectorFor;
    injector.destroy = function() {
      return destroyed = true;
    };
    return injector;
  };

  andReturn = function(afterAdvice) {
    var fn;
    fn = this;
    if (!afterAdvice.apply) {
      afterAdvice = (function(value) {
        return function() {
          return value;
        };
      })(afterAdvice);
    }
    return function() {
      var args, def;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      def = fn.apply(this, args);
      return afterAdvice.apply(this, [def].concat(args));
    };
  };

  getName = function(target) {
    var _ref;
    return (_ref = getClass(target)) != null ? _ref.fullName : void 0;
  };

  getClass = function(target) {
    return (target != null ? target.Class : void 0) || (target != null ? target.constructor : void 0);
  };

  mapper = function(config) {
    var mapProperty;
    return mapProperty = function(property) {
      var _ref;
      return (config != null ? (_ref = config.inject) != null ? _ref[property] : void 0 : void 0) || property;
    };
  };

  exports.Inject = inject;

  /*
  	Plugins can define 3 methods:
  
  	* init(pluginSupport) - passed the plugin support object, which has some helper functions.
  	* processDefinition(target,definitions) -
  		can return an additional definition object that will override the other definitions.
  		DO NOT call pluginSupport.definition inside this method.
  	* resolveFactory(target,name,targetDefinition) -
  		can return a factory function that will override the defined factory.
  */


  pluginSupport = {
    /*
    		Helper for getting a copy of the definition used to inject the given object in the current context.
    
    		@param {Object|String} target the thing to be injected, or its name. Some plugins may
    		return a different definition for an instance than they would for the name.
    		@return {Object} a copy of the injection definition for target in the current injector.
    */

    definition: function(target) {
      var context;
      context = last(CONTEXT);
      if (!context) {
        noContext();
      }
      if (typeof target === 'string') {
        target = {
          Class: {
            fullName: target
          }
        };
      }
      return context.definition(target);
    }
  };

  inject.plugin = function(plugin) {
    PLUGINS.push(plugin);
    if (plugin.init) {
      return plugin.init(pluginSupport);
    }
  };

  groupBy = function(array, fn) {
    var e, key, obj, prop, _i, _len;
    prop = fn;
    if (!(fn.call && fn.apply)) {
      fn = function(it) {
        return it != null ? it[prop] : void 0;
      };
    }
    obj = {};
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      e = array[_i];
      key = fn(e);
      if (obj[key]) {
        obj[key].push(e);
      } else {
        obj[key] = [e];
      }
    }
    return obj;
  };

  last = function(array) {
    return array != null ? array[(array != null ? array.length : void 0) - 1] : void 0;
  };

}).call(this);
